#ifndef CENTRALIZER
#define CENTRALIZER

#include "garsideuss.h"

namespace cgarside::centralizer {

template <class B> class Centralizer {
  private:
    std::unordered_set<B> generators;

  public:
    using ConstIterator = typename std::unordered_set<B>::const_iterator;

    inline ConstIterator begin() const { return generators.begin(); }

    inline ConstIterator end() const { return generators.end(); }

    inline void insert(const B &b) { generators.insert(b); }

    inline size_t number_of_generators() { return generators.size(); }

    inline bool mem(const B &b) {
        return generators.find(b) != generators.end();
    }

    void debug(IndentedOStream &os = ind_cout) {
        bool is_first = true;
        os << "{   ";
        os.Indent(4);
        os << "generators:";
        os.Indent(4);
        os << EndLine();
        os << "{   ";
        os.Indent(4);
        for (ConstIterator it = begin(); it != end(); it++) {
            if (!is_first) {
                os << "," << EndLine();
            } else {
                is_first = false;
            }
            (*it).debug(os);
        }
        os.Indent(-4);
        os << EndLine();
        os << "}";
        os.Indent(-8);
        os << EndLine();
        os << "}";
    }

    void print(IndentedOStream &os = ind_cout) {
        os << "The centralizer is generated by the following element"
           << (number_of_generators() > 1 ? "s" : "") << ":" << EndLine(2);

        os << "───────────" << (number_of_generators() > 1 ? "─" : "")
           << EndLine() << " Generator"
           << (number_of_generators() > 1 ? "s " : " ") << EndLine()
           << "───────────" << (number_of_generators() > 1 ? "─" : "");

        os.Indent(4);

        os << EndLine(1);

        sint16 indent =
            (int(std::to_string(number_of_generators() - 1).length()) + 1) / 4 +
            1;
        sint16 count = 0;
        for (ConstIterator it = begin(); it != end(); it++) {
            os << count << ":";
            for (size_t _ = 0;
                 _ < 4 * indent - 1 -
                         std::to_string(number_of_generators() - 1).length();
                 _++) {
                os << " ";
            }
            count++;
            os.Indent(4 * indent);
            (*it).print(os);
            os.Indent(-4 * indent);
            os << EndLine();
        }
        os.Indent(-4);
        os << EndLine(1);
    }
};

template <class F>
Centralizer<BraidTemplate<F>>
centralizer(const ultra_summit::UltraSummitSet<BraidTemplate<F>> &uss,
            const std::vector<F> &mins, const std::vector<sint16> &prev) {
    BraidTemplate<F> b = uss.at(0, 0);

    Centralizer<BraidTemplate<F>> centralizer;

    for (size_t orbit_index = 0; orbit_index < uss.number_of_orbits();
         orbit_index++) {
        BraidTemplate<F> d = ultra_summit::tree_path(
                             uss.at(orbit_index, (size_t)0), uss, mins, prev),
                         c = d, b2(b.get_parameter());
        for (size_t shift = 0; shift < uss.orbit_size(orbit_index); shift++) {
            c.right_multiply(
                uss.at(orbit_index, shift).First().delta_conjugate(b.Inf()));
        }
        c.right_multiply(!d);

        if ((!(c.is_identity())) && !centralizer.mem(c)) {
            centralizer.insert(c);
        }

        BraidTemplate<F> orbit_base_rcf = uss.at(orbit_index, (size_t)0);
        orbit_base_rcf.MakeRCFFromLCF();

        std::vector<F> min = ultra_summit::min_ultra_summit(
            uss.at(orbit_index, (size_t)0), orbit_base_rcf);

        for (typename std::vector<F>::const_iterator it = min.begin();
             it != min.end(); it++) {
            b2 = uss.at(orbit_index, (size_t)0);
            b2.Conjugate(*it);
            c = d * (*it) * !ultra_summit::tree_path(b2, uss, mins, prev);

            if ((!(c.is_identity())) && !centralizer.mem(c)) {
                centralizer.insert(c);
            }
        }
    }

    return centralizer;
}

template <class F>
Centralizer<BraidTemplate<F>> centralizer(const BraidTemplate<F> &b) {
    std::vector<F> mins;
    std::vector<sint16> prev;

    Centralizer<BraidTemplate<F>> centralizer_uss = centralizer(
                                      ultra_summit::ultra_summit_set(b, mins,
                                                                     prev),
                                      mins, prev),
                                  centralizer;

    BraidTemplate<F> c = BraidTemplate<F>(b.get_parameter()), d = c;
    ultra_summit::send_to_ultra_summit(b, c);
    c = !c;

    for (typename Centralizer<BraidTemplate<F>>::ConstIterator it =
             centralizer_uss.begin();
         it != centralizer_uss.end(); it++) {
        d = *it;
        d.Conjugate(c);
        centralizer.insert(d);
    }

    return centralizer;
}

} // namespace cgarside::centralizer

#endif